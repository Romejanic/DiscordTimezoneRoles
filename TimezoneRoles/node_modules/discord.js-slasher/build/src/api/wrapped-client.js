"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlasherClient = void 0;
const discord_js_1 = require("discord.js");
const fs = require("fs");
class SlasherClient extends discord_js_1.Client {
    constructor(options) {
        super(filterOptions(options));
        this.botToken = getBotToken(options);
        this.addCommandHandler();
    }
    addCommandHandler() {
        this.on("interactionCreate", (interaction) => {
            // ignore the interaction if it's not a command
            if (!interaction.isCommand())
                return;
            // create command context object
            let cmd = interaction;
            let ctx = {
                name: cmd.commandName,
                command: cmd,
                options: interaction.options,
                isServer: cmd.inGuild(),
                isDM: cmd.channel && cmd.channel.type === "DM",
                channel: cmd.channel,
                user: cmd.user,
                client: this,
                server: cmd.inGuild() ? {
                    guild: cmd.guild,
                    name: cmd.guild.name,
                    id: cmd.guild.id,
                    member: cmd.guild.members.resolve(cmd.user.id),
                    owner: cmd.user.id === cmd.guild.ownerId,
                    isUserAdmin: cmd.guild.members.resolve(cmd.user.id).permissions.has("ADMINISTRATOR"),
                    channelPermissions: cmd.channel.permissionsFor(cmd.user)
                } : undefined,
                reply: function (content, hidden = false) {
                    let contentString = typeof content === "string" ? content : undefined;
                    let contentEmbed = typeof content === "object" && typeof content.title !== "undefined" ? content : undefined;
                    let contentOptions = typeof content === "object" && contentEmbed == undefined ? content : undefined;
                    if (contentOptions) {
                        contentOptions.ephemeral = hidden;
                        return cmd.reply(contentOptions);
                    }
                    else {
                        return cmd.reply({
                            content: contentString,
                            embeds: contentEmbed ? [contentEmbed] : undefined,
                            ephemeral: hidden
                        });
                    }
                },
                defer: function (hidden = false) {
                    return cmd.deferReply({
                        ephemeral: hidden
                    });
                },
                edit: function (content) {
                    let contentString = typeof content === "string" ? content : undefined;
                    let contentEmbed = typeof content === "object" && typeof content.title !== "undefined" ? content : undefined;
                    let contentOptions = typeof content === "object" && contentEmbed == undefined ? content : undefined;
                    if (contentOptions) {
                        return cmd.editReply(contentOptions).then(m => m);
                    }
                    else {
                        return cmd.editReply({
                            content: contentString,
                            embeds: contentEmbed ? [contentEmbed] : undefined
                        }).then(m => m);
                    }
                }
            };
            // emit the command event with the context
            this.emit("command", ctx);
        });
    }
    login(token) {
        if (!token)
            return super.login(this.botToken);
        else {
            console.warn("Detected token being passed to login function! You should add it to the client options instead.");
            return super.login(token);
        }
    }
}
exports.SlasherClient = SlasherClient;
// gets the token from either the options or the auth.json file
function getBotToken(options) {
    if (options.token)
        return options.token;
    if (options.useAuth && fs.existsSync("auth.json")) {
        let data = fs.readFileSync("auth.json");
        let json = JSON.parse(data.toString());
        return json.token;
    }
    else {
        console.warn("Could not find bot token in client options or auth.json!");
        console.warn("You must either provide a token or set useAuth to true!");
    }
    return null;
}
// ensures the client options contains the GUILDS intent
function filterOptions(options) {
    let finalOptions = options;
    if (!options.intents) {
        finalOptions.intents = [discord_js_1.Intents.FLAGS.GUILDS];
    }
    else if (Array.isArray(options.intents)) {
        finalOptions.intents = [...options.intents, discord_js_1.Intents.FLAGS.GUILDS];
    }
    else if (typeof options.intents === "number") {
        finalOptions.intents = options.intents & discord_js_1.Intents.FLAGS.GUILDS;
    }
    else if (typeof options.intents === "string") {
        // this probably shouldn't be used, but maybe the user
        // needs a specific intent other than GUILDS? just leave
        // it be
        finalOptions.intents = options.intents;
    }
    delete options.token;
    return finalOptions;
}
