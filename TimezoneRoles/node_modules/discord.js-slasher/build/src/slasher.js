#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const colors = require("ansi-colors");
const readline = require("readline");
const stream_1 = require("stream");
const command_preview_1 = require("./command-preview");
const rest_1 = require("@discordjs/rest");
const v9_1 = require("discord-api-types/v9");
const OPTION_TYPES = {
    "subcommand": 1,
    "subcommand_group": 2,
    "string": 3,
    "integer": 4,
    "boolean": 5,
    "user": 6,
    "channel": 7,
    "role": 8,
    "mentionable": 9,
    "number": 10
};
const OPTION_TYPE_TEST = Object.keys(OPTION_TYPES).filter(s => s !== "subcommand" && s !== "subcommand_group");
const CHANNEL_TYPES = {
    "text": 0,
    "dm": 1,
    "voice": 2,
    "group_dm": 3,
    "category": 4,
    "announcements": 5,
    "store": 6,
    "announcement_thread": 10,
    "public_thread": 11,
    "private_thread": 12,
    "stage": 13
};
const NUM_CHANNEL_TYPES = Object.keys(CHANNEL_TYPES).length;
(() => __awaiter(void 0, void 0, void 0, function* () {
    console.log("S/ASHER " + require("../../package.json").version + " by Romejanic");
    console.log();
    // check the command definition exists
    if (!fs.existsSync("commands.json")) {
        console.error(colors.red("!! ERROR !!"));
        console.error(colors.red("You do not have a command file in your project!"));
        console.error(colors.red("Please create a " + colors.bold.red("commands.json") + " file in the base of your project."));
        return;
    }
    // read file and parse JSON
    let commandData;
    try {
        let data = yield fs.promises.readFile("commands.json");
        commandData = JSON.parse(data.toString());
        // remove json schema field
        if (commandData["$schema"]) {
            delete commandData["$schema"];
        }
    }
    catch (e) {
        console.error(colors.red("Failed to load your command.json file!"));
        console.error();
        console.error(colors.red(e));
    }
    // start analysing file
    console.log("Validating command tree...");
    let errors = validateTree(commandData);
    if (errors.length > 0) {
        console.error(colors.red("Failed to validate the command tree!"));
        console.error();
        console.error(errors.map(e => colors.red(e)).join("\n"));
        return;
    }
    // generate possible command list
    console.log("Calculating full command list...");
    let preview = new command_preview_1.default();
    let commands = [];
    getPossibleCommands(commandData, commands, preview);
    console.log();
    console.log(colors.bold.yellow("Command tree has been evaluated, these are the possible commands:"));
    console.log(commands.map(s => colors.yellow("  /" + s)).join("\n"));
    console.log();
    let muted = new BooleanRef(false);
    let rl = promised(readline.createInterface({
        input: process.stdin,
        output: new stream_1.Writable({
            write: (chunk, encoding, cb) => {
                if (muted.get()) {
                    let len = 1;
                    if (chunk.length) {
                        len = chunk.length;
                    }
                    let txt = Array(chunk).map(s => "*").join("");
                    process.stdout.write(Buffer.from(txt));
                }
                else {
                    process.stdout.write(chunk, encoding);
                }
                cb();
            }
        }),
        terminal: true
    }));
    let confirm = yield yesNo(colors.yellow("Are these correct? (y/n)"), rl);
    if (!confirm) {
        console.log();
        console.log(colors.red("Cancelled"));
        return process.exit(0);
    }
    // perform dry run if option is passed
    if (process.argv.includes("--dry-run")) {
        let data = generateDiscordJson(commandData);
        let json = JSON.stringify(data, null, 4);
        console.log(colors.gray("Dry run complete, generated Discord JSON:"));
        console.log(colors.yellow(json));
        return process.exit(0);
    }
    // check if they are uploading guild or global commands
    console.log();
    console.log(colors.yellow.bold("How would you like to upload the commands?"));
    console.log(colors.yellow("  1. For a specific server (updates instantly - use for testing)"));
    console.log(colors.yellow("  2. For all servers       (may take up to an hour to update)"));
    console.log();
    let num = -1;
    while (num != 1 && num != 2) {
        let init = num == -1;
        let ans = yield rl.question(init ? colors.yellow("Please choose an option (1/2) ") : colors.red("Please enter either 1 or 2: "));
        let n = Number(ans);
        if (isNaN(n)) {
            num = -2;
        }
        else {
            num = n;
        }
    }
    let updateGlobal = num === 2;
    console.log();
    let token;
    let client;
    let guild = undefined;
    // check if the auth.json file exists
    if (fs.existsSync("auth.json")) {
        // file exists, use it's details
        let data = yield fs.promises.readFile("auth.json");
        let json = JSON.parse(data.toString());
        token = json.token;
        client = json.client;
        guild = json.guild;
        // if the user hasn't saved a guild id yet, we'll still need
        // to prompt the user for it, then save it to the file
        if (!guild && !updateGlobal) {
            guild = yield rl.question(colors.yellow("Please enter the ID of the server to update (right click on server and copy ID): "));
            // write to json
            json.guild = guild;
            try {
                yield fs.promises.writeFile("auth.json", JSON.stringify(json, null, 4));
            }
            catch (e) { /* this can just silently fail */ }
        }
    }
    else {
        // doesn't exist, prompt the user for it
        token = yield tokenInput(colors.yellow("Please enter your bot's token (that you would use to log into it): "), rl, muted);
        client = yield rl.question(colors.yellow("Please enter the ID of your bot's account (right click on your bot and copy ID): "));
        if (!updateGlobal) {
            guild = yield rl.question(colors.yellow("Please enter the ID of the server to update (right click on server and copy ID): "));
        }
    }
    // prompt user to save details
    yield askToSave(token, client, guild, rl);
    // confirm before performing the update
    console.log();
    console.log(colors.yellow.bold("Great! Your bot's commands will now be updated " + (updateGlobal ? "globally" : "for your server")));
    if (updateGlobal) {
        console.log(colors.yellow("(Please note that it may take up to an hour for your changes to be applied)"));
    }
    console.log();
    confirm = yield yesNo(colors.yellow("Are you ready to proceed? (y/n): "), rl);
    if (!confirm) {
        console.log();
        console.log(colors.red("Cancelled"));
        return process.exit(0);
    }
    // generate discord json and send request
    let data = generateDiscordJson(commandData);
    console.log();
    console.log(colors.gray("Please wait..."));
    let rest = new rest_1.REST({ version: '9' }).setToken(token);
    try {
        let route = updateGlobal ? v9_1.Routes.applicationCommands(client) : v9_1.Routes.applicationGuildCommands(client, guild);
        // let existingCommands: ExistingCommand[] = (await rest.get(route)) as ExistingCommand[];
        // let commandsToDelete = existingCommands.filter(cmd => typeof commandData[cmd.name] === "undefined");
        // console.log(existingCommands, commandsToDelete);
        yield rest.put(route, { body: data });
        console.log(colors.green.bold("Done! You should see the updated commands in Discord soon."));
    }
    catch (e) {
        console.log(colors.red.bold("Error updating commands with Discord!"));
        console.log(colors.red("Please check the following error as it may be an issue with your command tree."));
        console.log();
        console.log(colors.red(e));
    }
    process.exit(0);
}))();
function askToSave(token, client, guild, intf) {
    return __awaiter(this, void 0, void 0, function* () {
        function appendToGitIgnore() {
            return __awaiter(this, void 0, void 0, function* () {
                const gitignore = "\n# Bot Authorisation File\n/auth.json";
                yield new Promise((resolve, reject) => {
                    fs.appendFile(".gitignore", gitignore, (err) => {
                        if (err)
                            reject(err);
                        else
                            resolve();
                    });
                });
                console.log();
                console.log(colors.red("## NOTE ##"));
                console.log(colors.red("An entry for auth.json was added to your .gitignore file."));
                console.log(colors.red.bold("If you use a different version control system, add it to the ignore file!"));
                console.log(colors.red.bold("NEVER EVER EVER " + colors.underline.red.bold("EVER") + " commit auth.json to your repository!!!!"));
                console.log(colors.red("Doing so could make your bot token public, and open it up to being hijacked. Not good!"));
            });
        }
        if (fs.existsSync("auth.json")) {
            // check if it's in the gitignore
            if (yield authFileNotInGitIgnore()) {
                yield appendToGitIgnore();
            }
        }
        else {
            console.log();
            let confirm = yield yesNo(colors.yellow("Would you like to save these details for future use? (y/n):"), intf);
            if (confirm) {
                // append entry to gitignore
                try {
                    if (yield authFileNotInGitIgnore()) {
                        yield appendToGitIgnore();
                    }
                }
                catch (e) {
                    console.log(colors.red.bold("Failed to append entry to gitignore file!"));
                    console.log(colors.bold("For security reasons the details were not saved"));
                    return;
                }
                // write json to file
                yield new Promise((resolve, reject) => {
                    let json = JSON.stringify({
                        token, client, guild
                    }, null, 4);
                    fs.writeFile("auth.json", json, (err) => {
                        if (err)
                            reject(err);
                        else
                            resolve();
                    });
                });
                console.log(colors.green("Saved bot login details to auth.json!"));
            }
        }
    });
}
function validateTree(tree) {
    // define separate validation functions
    function validateCommand(prefix, command) {
        if (typeof command !== "object")
            return prefix + "command must be object";
        if (!command.description)
            return prefix + "requires a description!";
        if (typeof command.description !== "string")
            return prefix + "description must be string";
        if (command.options && typeof command.options !== "object")
            return prefix + "options must be object";
        return null;
    }
    function validateOptionBasic(prefix, option) {
        if (typeof option !== "object")
            return prefix + "option must be object";
        if (!option.description)
            return prefix + "requires a description!";
        if (typeof option.description !== "string")
            return prefix + "description must be string";
        return null;
    }
    function validateOption(prefix, option) {
        if (typeof option.required !== "undefined" && typeof option.required !== "boolean")
            return prefix + "required must be boolean";
        let type = null;
        if (option.choices) {
            if (typeof option.choices !== "object")
                return prefix + "choices must be object";
            for (let choiceName in option.choices) {
                if (typeof choiceName !== "string")
                    return prefix + "choice \"" + choiceName + "\": name must be string";
                if (typeof option.choices[choiceName] !== "string" && typeof option.choices[choiceName] !== "number") {
                    return prefix + "choice \"" + choiceName + "\": value must be string or number";
                }
                if (type) {
                    if (typeof option.choices[choiceName] !== type)
                        return prefix + "choice \"" + choiceName + "\": all choices must have same type";
                }
                else {
                    type = typeof option.choices[choiceName];
                }
            }
        }
        else if (option.channel_types) {
            if (!Array.isArray(option.channel_types))
                return prefix + "channel_types must be array";
            if (option.channel_types.length < 1 || option.channel_types.length > NUM_CHANNEL_TYPES)
                return prefix + "channel_types must have between 1 and " + NUM_CHANNEL_TYPES + " types";
            if (option.channel_types.some(k => typeof CHANNEL_TYPES[k] === "undefined"))
                return prefix + "each element of channel_types must be one of: " + Object.keys(CHANNEL_TYPES).join(", ");
            // get unique values only
            option.channel_types = option.channel_types.filter((v, i, s) => s.indexOf(v) === i);
        }
        else if (typeof option.type !== "string") {
            return prefix + "type must be defined if no choices are provided";
        }
        else if (!OPTION_TYPE_TEST.includes(option.type)) {
            return prefix + "type must be one of: " + OPTION_TYPE_TEST.join(", ");
        }
        return null;
    }
    function validateOptions(cmd, commandName) {
        for (let optionName in cmd.options) {
            // test name against regex
            if (!namePat.test(optionName)) {
                track("command \"" + commandName + "\" option \"" + optionName + "\": option name is invalid");
                continue;
            }
            // test basic option data
            let optionBasic = cmd.options[optionName];
            let optionPrefix = "command \"" + commandName + "\" option \"" + optionName + "\": ";
            track(validateOptionBasic(optionPrefix, optionBasic));
            // determine if option is subcommand or subcommand group
            let option = optionBasic;
            let subcmd = optionBasic;
            let subcmdGroup = optionBasic;
            if (subcmdGroup.subcommands) {
                // option is subcommand group
                for (let scmd in subcmdGroup.subcommands) {
                    let subg = subcmdGroup.subcommands[scmd];
                    if (subg.subcommands) {
                        track("command \"" + commandName + "\" subcommand group \"" + optionName + "\": subcommand group cannot contain subcommand group");
                        continue;
                    }
                    let subc = subcmdGroup.subcommands[scmd];
                    if (typeof subc !== "object" || (!subc.options && !subc.subcommand)) {
                        track("command \"" + commandName + "\" subcommand group \"" + optionName + "\" subcommand \"" + scmd + "\": must be a subcommand object");
                        continue;
                    }
                }
                validateOptions({ description: subcmdGroup.description, options: subcmdGroup.subcommands }, commandName + "/" + optionName);
            }
            else if (subcmd.options || subcmd.subcommand) {
                // option is subcommand
                validateOptions(subcmd, commandName + "/" + optionName);
            }
            else {
                // option is option (lol)
                track(validateOption(optionPrefix, option));
            }
        }
    }
    // add error tracking
    let errors = [];
    function track(error) {
        if (error)
            errors.push(error);
    }
    // start validation
    let namePat = /^[\w-]{1,32}$/;
    for (let commandName in tree) {
        // test name against regex
        if (!namePat.test(commandName)) {
            track("command \"" + commandName + "\": command name is invalid");
            continue;
        }
        // test basic command data
        let cmd = tree[commandName];
        let cmdPrefix = "command \"" + commandName + "\": ";
        track(validateCommand(cmdPrefix, cmd));
        // test options
        if (cmd.options) {
            validateOptions(cmd, commandName);
        }
    }
    return errors;
}
function getPossibleCommands(tree, commands, preview) {
    // for the first release just keep it simple,
    // only lists the command names
    commands.push(...Object.keys(tree));
    // for(let commandName in tree) {
    //     preview.push(commandName);
    //     let command = tree[commandName] as Types.Command;
    //     if(!command.options) {
    //         commands.push(preview.get());
    //     } else {
    //         getPossibleOptionCommands(command.options, commands, preview);
    //     }
    //     preview.pop();
    // }
}
function getPossibleOptionCommands(options, commands, preview) {
    let offset = 0;
    for (let optionName in options) {
        if (!options[optionName]) {
            offset++;
            continue;
        }
        let option = options[optionName];
        let subcmd = options[optionName];
        let subcmdGroup = options[optionName];
        if (subcmdGroup.subcommands) {
            preview.push(optionName);
            getPossibleOptionCommands(subcmdGroup.subcommands, commands, preview);
        }
        else if (subcmd.options) {
            preview.push(optionName);
            getPossibleOptionCommands(subcmd.options, commands, preview);
        }
        else if (subcmd.subcommand) {
            preview.push(optionName);
        }
        else {
            let required = typeof option.required === "boolean" && option.required;
            preview.push((!required ? "?" : "") + optionName);
        }
    }
    commands.push(preview.get());
    for (let i = 0; i < Object.keys(options).length - offset; i++) {
        preview.pop();
    }
}
function generateDiscordJson(tree) {
    let commands = [];
    for (let commandName in tree) {
        let command = tree[commandName];
        let options;
        if (typeof command.options === "object") {
            options = generateOptionJson(command.options);
        }
        commands.push({
            name: commandName,
            description: command.description,
            options: options ? options : undefined
        });
    }
    return commands;
}
function generateOptionJson(options) {
    let optionData = [];
    for (let optionName in options) {
        let option = options[optionName];
        let type;
        let required;
        let choices;
        let channel_types;
        let subg = option;
        let subc = option;
        let opt = option;
        if (subg.subcommands) {
            // is a subcommand group
            type = OPTION_TYPES["subcommand_group"];
            let optionsArray = generateOptionJson(subg.subcommands);
            optionData.push({
                name: optionName,
                description: option.description,
                type, options: optionsArray
            });
        }
        else if (subc.options || subc.subcommand) {
            // is a subcommand
            type = OPTION_TYPES["subcommand"];
            let optionsArray = undefined;
            if (subc.options) {
                optionsArray = generateOptionJson(subc.options);
            }
            optionData.push({
                name: optionName,
                description: option.description,
                type, options: optionsArray
            });
        }
        else {
            // is a regular option
            if (opt.choices) {
                let first = opt.choices[Object.keys(opt.choices)[0]];
                type = typeof first === "string" ? OPTION_TYPES["string"] : OPTION_TYPES["number"];
                choices = Object.keys(opt.choices).map((name) => {
                    return { name, value: opt.choices[name] };
                });
            }
            else if (opt.channel_types) {
                type = OPTION_TYPES["channel"];
                channel_types = opt.channel_types.map(v => CHANNEL_TYPES[v]);
            }
            else {
                type = OPTION_TYPES[opt.type];
            }
            if (opt.required) {
                required = opt.required;
            }
            // add option data
            optionData.push({
                name: optionName,
                description: option.description,
                type, required, choices, channel_types
            });
        }
    }
    return optionData;
}
//------------------------------------------------------------------------------------//
function yesNo(query, intf) {
    return __awaiter(this, void 0, void 0, function* () {
        let answer;
        while (answer != "y" && answer != "n" && answer != "yes" && answer != "no") {
            let q = answer ? colors.red("Please enter one of: (y, n, yes, no): ") : query + " ";
            answer = (yield intf.question(q)).toLowerCase();
        }
        return answer == "y" || answer == "yes";
    });
}
function tokenInput(query, intf, muted) {
    return new Promise((resolve) => {
        intf.reference.question(query, (answer) => {
            muted.set(false);
            process.stdout.write("\n");
            resolve(answer);
        });
        muted.set(true);
    });
}
function promised(intf) {
    return {
        reference: intf,
        question: (query) => {
            return new Promise((resolve) => {
                intf.question(query, (answer) => {
                    resolve(answer);
                });
            });
        }
    };
}
class BooleanRef {
    constructor(value) {
        this.value = value;
    }
    set(value) {
        this.value = value;
    }
    get() {
        return this.value;
    }
}
function authFileNotInGitIgnore() {
    return __awaiter(this, void 0, void 0, function* () {
        const file = ".gitignore";
        if (!fs.existsSync(file))
            return true;
        const data = yield fs.promises.readFile(file);
        return !data.toString().includes("/auth.json");
    });
}
